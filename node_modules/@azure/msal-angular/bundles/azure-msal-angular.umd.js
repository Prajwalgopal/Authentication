(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('msal'), require('@angular/router'), require('@angular/common'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('@azure/msal-angular', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', 'msal', '@angular/router', '@angular/common', '@angular/common/http'], factory) :
    (global = global || self, factory((global.azure = global.azure || {}, global.azure['msal-angular'] = {}), global.ng.core, global.rxjs, global.rxjs.operators, global.msal, global.ng.router, global.ng.common, global.ng.common.http));
}(this, (function (exports, core, rxjs, operators, msal, router, common, http) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var BroadcastService = /** @class */ (function () {
        function BroadcastService() {
            this._msalSubject = new rxjs.BehaviorSubject(1);
            this.msalItem$ = this._msalSubject.asObservable();
        }
        BroadcastService.prototype.broadcast = function (type, payload) {
            this._msalSubject.next({ type: type, payload: payload });
        };
        BroadcastService.prototype.getMSALSubject = function () {
            return this._msalSubject;
        };
        BroadcastService.prototype.getMSALItem = function () {
            return this.msalItem$;
        };
        BroadcastService.prototype.subscribe = function (type, callback) {
            return this.msalItem$
                .pipe(operators.filter(function (message) { return message.type === type; }), operators.map(function (message) { return message.payload; }))
                .subscribe(callback);
        };
        BroadcastService = __decorate([
            core.Injectable()
        ], BroadcastService);
        return BroadcastService;
    }());

    var MSALError = /** @class */ (function () {
        function MSALError(error, errorDesc, scopes) {
            this._error = "";
            this._errorDesc = "";
            this._scopes = "";
            this._error = error;
            if (errorDesc) {
                this._errorDesc = errorDesc;
            }
            if (scopes) {
                this._scopes = scopes;
            }
        }
        Object.defineProperty(MSALError.prototype, "error", {
            get: function () {
                return this._error;
            },
            set: function (value) {
                this._error = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MSALError.prototype, "errorDesc", {
            get: function () {
                return this._errorDesc;
            },
            set: function (value) {
                this._errorDesc = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MSALError.prototype, "scopes", {
            get: function () {
                return this._scopes;
            },
            set: function (value) {
                this._scopes = value;
            },
            enumerable: true,
            configurable: true
        });
        return MSALError;
    }());

    var MSAL_CONFIG = new core.InjectionToken("MSAL_CONFIG");
    var MSAL_CONFIG_ANGULAR = new core.InjectionToken("MSAL_CONFIG_ANGULAR");

    var buildMsalConfig = function (config) {
        return __assign(__assign({}, config), { framework: __assign(__assign({}, config.framework), { isAngular: true }) });
    };
    var ɵ0 = buildMsalConfig;
    var MsalService = /** @class */ (function (_super) {
        __extends(MsalService, _super);
        function MsalService(msalConfig, msalAngularConfig, router, broadcastService) {
            var _this = _super.call(this, buildMsalConfig(msalConfig)) || this;
            _this.msalConfig = msalConfig;
            _this.msalAngularConfig = msalAngularConfig;
            _this.router = router;
            _this.broadcastService = broadcastService;
            window.addEventListener("msal:popUpHashChanged", function (e) {
                _this.getLogger().verbose("popUpHashChanged ");
            });
            window.addEventListener("msal:popUpClosed", function (e) {
                var errorParts = e.detail.split("|");
                var msalError = new MSALError(errorParts[0], errorParts[1]);
                if (_this.getLoginInProgress()) {
                    broadcastService.broadcast("msal:loginFailure", msalError);
                    _this.setloginInProgress(false);
                }
                else if (_this.getAcquireTokenInProgress()) {
                    broadcastService.broadcast("msal:acquireTokenFailure", msalError);
                    _this.setAcquireTokenInProgress(false);
                }
            });
            _this.router.events.subscribe(function (event) {
                for (var i = 0; i < router.config.length; i++) {
                    if (!router.config[i].canActivate) {
                        if (_this.msalAngularConfig.unprotectedResources) {
                            if (!_this.isEmpty(router.config[i].path) && !_this.isUnprotectedResource(router.config[i].path)) {
                                _this.msalAngularConfig.unprotectedResources.push(router.config[i].path);
                            }
                        }
                    }
                }
            });
            return _this;
        }
        MsalService.prototype.isUnprotectedResource = function (url) {
            var frameworkUnprotectedResources = this.msalConfig.framework && this.msalConfig.framework.unprotectedResources;
            var configUnprotectedResources = this.msalAngularConfig.unprotectedResources || [];
            var unprotectedResources = frameworkUnprotectedResources && frameworkUnprotectedResources.length ? frameworkUnprotectedResources : configUnprotectedResources;
            return unprotectedResources.some(function (resource) { return url.indexOf(resource) > -1; });
        };
        MsalService.prototype.isEmpty = function (str) {
            return (typeof str === "undefined" || !str || 0 === str.length);
        };
        MsalService.prototype.loginPopup = function (request) {
            var _this = this;
            return _super.prototype.loginPopup.call(this, request)
                .then(function (authResponse) {
                _this.broadcastService.broadcast("msal:loginSuccess", authResponse);
                return authResponse;
            })
                .catch(function (error) {
                _this.broadcastService.broadcast("msal:loginFailure", error);
                _this.getLogger().error("Error during login:\n" + error.errorMessage);
                throw error;
            });
        };
        MsalService.prototype.ssoSilent = function (request) {
            var _this = this;
            return _super.prototype.ssoSilent.call(this, request)
                .then(function (authResponse) {
                _this.broadcastService.broadcast("msal:ssoSuccess", authResponse);
                return authResponse;
            })
                .catch(function (error) {
                _this.broadcastService.broadcast("msal:ssoFailure", error);
                _this.getLogger().error("Error during login:\n" + error.errorMessage);
                throw error;
            });
        };
        MsalService.prototype.acquireTokenSilent = function (request) {
            var _this = this;
            return _super.prototype.acquireTokenSilent.call(this, request)
                .then(function (authResponse) {
                _this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
                return authResponse;
            })
                .catch(function (error) {
                _this.broadcastService.broadcast("msal:acquireTokenFailure", error);
                _this.getLogger().error("Error when acquiring token for scopes: " + request.scopes + " " + error);
                throw error;
            });
        };
        MsalService.prototype.acquireTokenPopup = function (request) {
            var _this = this;
            return _super.prototype.acquireTokenPopup.call(this, request)
                .then(function (authResponse) {
                _this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
                return authResponse;
            })
                .catch(function (error) {
                _this.broadcastService.broadcast("msal:acquireTokenFailure", error);
                _this.getLogger().error("Error when acquiring token for scopes : " + request.scopes + " " + error);
                throw error;
            });
        };
        MsalService.prototype.handleRedirectCallback = function (authOrTokenCallback, errorReceivedCallback) {
            var _this = this;
            _super.prototype.handleRedirectCallback.call(this, function (authError, authResponse) {
                if (authError) {
                    if (!_this.getAccount()) {
                        _this.broadcastService.broadcast("msal:loginFailure", authError);
                    }
                    else {
                        _this.broadcastService.broadcast("msal:acquireTokenFailure", authError);
                    }
                    if (errorReceivedCallback) {
                        errorReceivedCallback(authError, authResponse.accountState);
                    }
                    else {
                        authOrTokenCallback(authError, authResponse);
                    }
                }
                else if (authResponse) {
                    if (authResponse.tokenType === "id_token") {
                        _this.broadcastService.broadcast("msal:loginSuccess", authResponse);
                    }
                    else {
                        _this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
                    }
                    if (errorReceivedCallback) {
                        authOrTokenCallback(authResponse);
                    }
                    else {
                        authOrTokenCallback(null, authResponse);
                    }
                }
            });
        };
        MsalService.prototype.clearCacheForScope = function (accessToken) {
            return _super.prototype.clearCacheForScope.call(this, accessToken);
        };
        MsalService.prototype.getScopesForEndpoint = function (endpoint) {
            if (this.msalConfig.framework && this.msalConfig.framework.unprotectedResources) {
                this.getLogger().info("msalConfig.framework.unprotectedResources is deprecated, use msalAngularConfig.unprotectedResources");
            }
            // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.
            var isUnprotected = this.isUnprotectedResource(endpoint);
            if (isUnprotected) {
                return null;
            }
            var frameworkProtectedResourceMap = this.msalConfig.framework && this.msalConfig.framework.protectedResourceMap;
            if (frameworkProtectedResourceMap) {
                this.getLogger().info("msalConfig.framework.protectedResourceMap is deprecated, use msalAngularConfig.protectedResourceMap");
            }
            var protectedResourceMap = frameworkProtectedResourceMap && frameworkProtectedResourceMap.size ? frameworkProtectedResourceMap : new Map(this.msalAngularConfig.protectedResourceMap);
            // process all protected resources and send the matched one
            var keyForEndpoint = Array.from(protectedResourceMap.keys()).find(function (key) { return endpoint.indexOf(key) > -1; });
            if (keyForEndpoint) {
                return protectedResourceMap.get(keyForEndpoint);
            }
            /*
             * default resource will be clientid if nothing specified
             * App will use idtoken for calls to itself
             * check if it's staring from http or https, needs to match with app host
             */
            if (endpoint.indexOf("http://") > -1 || endpoint.indexOf("https://") > -1) {
                if (msal.UrlUtils.getHostFromUri(endpoint) === msal.UrlUtils.getHostFromUri(_super.prototype.getRedirectUri.call(this))) {
                    return new Array(this.msalConfig.auth.clientId);
                }
            }
            else {
                /*
                 * in angular level, the url for $http interceptor call could be relative url,
                 * if it's relative call, we'll treat it as app backend call.
                 */
                return new Array(this.msalConfig.auth.clientId);
            }
            // if not the app's own backend or not a domain listed in the endpoints structure
            return null;
        };
        MsalService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_CONFIG,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
            { type: router.Router },
            { type: BroadcastService }
        ]; };
        MsalService = __decorate([
            core.Injectable(),
            __param(0, core.Inject(MSAL_CONFIG)),
            __param(1, core.Inject(MSAL_CONFIG_ANGULAR))
        ], MsalService);
        return MsalService;
    }(msal.UserAgentApplication));

    var MsalGuard = /** @class */ (function () {
        function MsalGuard(msalConfig, msalAngularConfig, authService, router, activatedRoute, location, platformLocation, broadcastService) {
            this.msalConfig = msalConfig;
            this.msalAngularConfig = msalAngularConfig;
            this.authService = authService;
            this.router = router;
            this.activatedRoute = activatedRoute;
            this.location = location;
            this.platformLocation = platformLocation;
            this.broadcastService = broadcastService;
        }
        /**
         * Builds the absolute url for the destination page
         * @param path Relative path of requested page
         * @returns Full destination url
         */
        MsalGuard.prototype.getDestinationUrl = function (path) {
            // Absolute base url for the application (default to origin if base element not present)
            var baseElements = document.getElementsByTagName("base");
            var baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
            // Path of page (including hash, if using hash routing)
            var pathUrl = this.location.prepareExternalUrl(path);
            // Hash location strategy
            if (pathUrl.startsWith("#")) {
                return baseUrl + "/" + pathUrl;
            }
            // If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
            // Since baseUrl also includes /base, can just concatentate baseUrl + path
            return "" + baseUrl + path;
        };
        /**
         * Interactively prompt the user to login
         * @param url Path of the requested page
         */
        MsalGuard.prototype.loginInteractively = function (url) {
            return __awaiter(this, void 0, void 0, function () {
                var redirectStartPage;
                return __generator(this, function (_a) {
                    if (this.msalAngularConfig.popUp) {
                        return [2 /*return*/, this.authService.loginPopup({
                                scopes: this.msalAngularConfig.consentScopes,
                                extraQueryParameters: this.msalAngularConfig.extraQueryParameters
                            })
                                .then(function () { return true; })
                                .catch(function () { return false; })];
                    }
                    redirectStartPage = this.getDestinationUrl(url);
                    this.authService.loginRedirect({
                        redirectStartPage: redirectStartPage,
                        scopes: this.msalAngularConfig.consentScopes,
                        extraQueryParameters: this.msalAngularConfig.extraQueryParameters
                    });
                    return [2 /*return*/];
                });
            });
        };
        MsalGuard.prototype.canActivate = function (route, state) {
            var _this = this;
            this.authService.getLogger().verbose("location change event from old url to new url");
            // If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
            // short-circuit to prevent redirecting or popups.
            if (msal.UrlUtils.urlContainsHash(window.location.hash) && msal.WindowUtils.isInIframe()) {
                this.authService.getLogger().warning("redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
                return false;
            }
            if (!this.authService.getAccount()) {
                return this.loginInteractively(state.url);
            }
            return this.authService.acquireTokenSilent({
                scopes: [this.msalConfig.auth.clientId]
            })
                .then(function () { return true; })
                .catch(function (error) {
                if (msal.InteractionRequiredAuthError.isInteractionRequiredError(error.errorCode)) {
                    _this.authService.getLogger().info("Interaction required error in MSAL Guard, prompting for interaction.");
                    return _this.loginInteractively(state.url);
                }
                _this.authService.getLogger().error("Non-interaction error in MSAL Guard: " + error.errorMessage);
                throw error;
            });
        };
        MsalGuard.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_CONFIG,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
            { type: MsalService },
            { type: router.Router },
            { type: router.ActivatedRoute },
            { type: common.Location },
            { type: common.PlatformLocation },
            { type: BroadcastService }
        ]; };
        MsalGuard = __decorate([
            core.Injectable(),
            __param(0, core.Inject(MSAL_CONFIG)),
            __param(1, core.Inject(MSAL_CONFIG_ANGULAR))
        ], MsalGuard);
        return MsalGuard;
    }());

    var MsalInterceptor = /** @class */ (function () {
        function MsalInterceptor(auth, broadcastService) {
            this.auth = auth;
            this.broadcastService = broadcastService;
        }
        MsalInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            var scopes = this.auth.getScopesForEndpoint(req.url);
            this.auth.getLogger().verbose("Url: " + req.url + " maps to scopes: " + scopes);
            // If there are no scopes set for this request, do nothing.
            if (!scopes) {
                return next.handle(req);
            }
            var token;
            // Acquire a token for this request, and attach as proper auth header.
            return rxjs.from(this.auth.acquireTokenSilent({ scopes: scopes })
                .then(function (response) {
                token = response.tokenType === msal.ServerHashParamKeys.ID_TOKEN ? response.idToken.rawIdToken : response.accessToken;
                var authHeader = "Bearer " + token;
                return req.clone({
                    setHeaders: {
                        Authorization: authHeader,
                    }
                });
            }))
                .pipe(operators.mergeMap(function (nextReq) { return next.handle(nextReq); }), operators.tap(function (event) { }, // tslint:disable-line
            function (// tslint:disable-line
            err) {
                if (err instanceof http.HttpErrorResponse && err.status === 401) {
                    _this.auth.clearCacheForScope(token);
                    _this.broadcastService.broadcast("msal:notAuthorized", err.message);
                }
            }));
        };
        MsalInterceptor.ctorParameters = function () { return [
            { type: MsalService },
            { type: BroadcastService }
        ]; };
        MsalInterceptor = __decorate([
            core.Injectable()
        ], MsalInterceptor);
        return MsalInterceptor;
    }());

    var defaultMsalAngularConfiguration = {
        consentScopes: [],
        popUp: false,
        extraQueryParameters: {},
        unprotectedResources: [],
        protectedResourceMap: []
    };

    var MsalModule = /** @class */ (function () {
        function MsalModule() {
        }
        MsalModule_1 = MsalModule;
        MsalModule.forRoot = function (config, angularConfig) {
            if (angularConfig === void 0) { angularConfig = defaultMsalAngularConfiguration; }
            return {
                ngModule: MsalModule_1,
                providers: [
                    {
                        provide: MSAL_CONFIG,
                        useValue: config
                    },
                    {
                        provide: MSAL_CONFIG_ANGULAR,
                        useValue: angularConfig
                    },
                    MsalService
                ]
            };
        };
        var MsalModule_1;
        MsalModule = MsalModule_1 = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [],
                providers: [MsalGuard, BroadcastService],
            })
        ], MsalModule);
        return MsalModule;
    }());

    exports.BroadcastService = BroadcastService;
    exports.MSAL_CONFIG = MSAL_CONFIG;
    exports.MSAL_CONFIG_ANGULAR = MSAL_CONFIG_ANGULAR;
    exports.MsalGuard = MsalGuard;
    exports.MsalInterceptor = MsalInterceptor;
    exports.MsalModule = MsalModule;
    exports.MsalService = MsalService;
    exports.ɵa = defaultMsalAngularConfiguration;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=azure-msal-angular.umd.js.map
