import { __decorate, __assign, __extends, __param, __awaiter, __generator } from 'tslib';
import { Injectable, InjectionToken, Inject, NgModule } from '@angular/core';
import { BehaviorSubject, from } from 'rxjs';
import { filter, map, mergeMap, tap } from 'rxjs/operators';
import { UrlUtils, UserAgentApplication, WindowUtils, InteractionRequiredAuthError, ServerHashParamKeys } from 'msal';
import { Router, ActivatedRoute } from '@angular/router';
import { Location, PlatformLocation, CommonModule } from '@angular/common';
import { HttpErrorResponse } from '@angular/common/http';

var BroadcastService = /** @class */ (function () {
    function BroadcastService() {
        this._msalSubject = new BehaviorSubject(1);
        this.msalItem$ = this._msalSubject.asObservable();
    }
    BroadcastService.prototype.broadcast = function (type, payload) {
        this._msalSubject.next({ type: type, payload: payload });
    };
    BroadcastService.prototype.getMSALSubject = function () {
        return this._msalSubject;
    };
    BroadcastService.prototype.getMSALItem = function () {
        return this.msalItem$;
    };
    BroadcastService.prototype.subscribe = function (type, callback) {
        return this.msalItem$
            .pipe(filter(function (message) { return message.type === type; }), map(function (message) { return message.payload; }))
            .subscribe(callback);
    };
    BroadcastService = __decorate([
        Injectable()
    ], BroadcastService);
    return BroadcastService;
}());

var MSALError = /** @class */ (function () {
    function MSALError(error, errorDesc, scopes) {
        this._error = "";
        this._errorDesc = "";
        this._scopes = "";
        this._error = error;
        if (errorDesc) {
            this._errorDesc = errorDesc;
        }
        if (scopes) {
            this._scopes = scopes;
        }
    }
    Object.defineProperty(MSALError.prototype, "error", {
        get: function () {
            return this._error;
        },
        set: function (value) {
            this._error = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MSALError.prototype, "errorDesc", {
        get: function () {
            return this._errorDesc;
        },
        set: function (value) {
            this._errorDesc = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MSALError.prototype, "scopes", {
        get: function () {
            return this._scopes;
        },
        set: function (value) {
            this._scopes = value;
        },
        enumerable: true,
        configurable: true
    });
    return MSALError;
}());

var MSAL_CONFIG = new InjectionToken("MSAL_CONFIG");
var MSAL_CONFIG_ANGULAR = new InjectionToken("MSAL_CONFIG_ANGULAR");

var buildMsalConfig = function (config) {
    return __assign(__assign({}, config), { framework: __assign(__assign({}, config.framework), { isAngular: true }) });
};
var ɵ0 = buildMsalConfig;
var MsalService = /** @class */ (function (_super) {
    __extends(MsalService, _super);
    function MsalService(msalConfig, msalAngularConfig, router, broadcastService) {
        var _this = _super.call(this, buildMsalConfig(msalConfig)) || this;
        _this.msalConfig = msalConfig;
        _this.msalAngularConfig = msalAngularConfig;
        _this.router = router;
        _this.broadcastService = broadcastService;
        window.addEventListener("msal:popUpHashChanged", function (e) {
            _this.getLogger().verbose("popUpHashChanged ");
        });
        window.addEventListener("msal:popUpClosed", function (e) {
            var errorParts = e.detail.split("|");
            var msalError = new MSALError(errorParts[0], errorParts[1]);
            if (_this.getLoginInProgress()) {
                broadcastService.broadcast("msal:loginFailure", msalError);
                _this.setloginInProgress(false);
            }
            else if (_this.getAcquireTokenInProgress()) {
                broadcastService.broadcast("msal:acquireTokenFailure", msalError);
                _this.setAcquireTokenInProgress(false);
            }
        });
        _this.router.events.subscribe(function (event) {
            for (var i = 0; i < router.config.length; i++) {
                if (!router.config[i].canActivate) {
                    if (_this.msalAngularConfig.unprotectedResources) {
                        if (!_this.isEmpty(router.config[i].path) && !_this.isUnprotectedResource(router.config[i].path)) {
                            _this.msalAngularConfig.unprotectedResources.push(router.config[i].path);
                        }
                    }
                }
            }
        });
        return _this;
    }
    MsalService.prototype.isUnprotectedResource = function (url) {
        var frameworkUnprotectedResources = this.msalConfig.framework && this.msalConfig.framework.unprotectedResources;
        var configUnprotectedResources = this.msalAngularConfig.unprotectedResources || [];
        var unprotectedResources = frameworkUnprotectedResources && frameworkUnprotectedResources.length ? frameworkUnprotectedResources : configUnprotectedResources;
        return unprotectedResources.some(function (resource) { return url.indexOf(resource) > -1; });
    };
    MsalService.prototype.isEmpty = function (str) {
        return (typeof str === "undefined" || !str || 0 === str.length);
    };
    MsalService.prototype.loginPopup = function (request) {
        var _this = this;
        return _super.prototype.loginPopup.call(this, request)
            .then(function (authResponse) {
            _this.broadcastService.broadcast("msal:loginSuccess", authResponse);
            return authResponse;
        })
            .catch(function (error) {
            _this.broadcastService.broadcast("msal:loginFailure", error);
            _this.getLogger().error("Error during login:\n" + error.errorMessage);
            throw error;
        });
    };
    MsalService.prototype.ssoSilent = function (request) {
        var _this = this;
        return _super.prototype.ssoSilent.call(this, request)
            .then(function (authResponse) {
            _this.broadcastService.broadcast("msal:ssoSuccess", authResponse);
            return authResponse;
        })
            .catch(function (error) {
            _this.broadcastService.broadcast("msal:ssoFailure", error);
            _this.getLogger().error("Error during login:\n" + error.errorMessage);
            throw error;
        });
    };
    MsalService.prototype.acquireTokenSilent = function (request) {
        var _this = this;
        return _super.prototype.acquireTokenSilent.call(this, request)
            .then(function (authResponse) {
            _this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
            return authResponse;
        })
            .catch(function (error) {
            _this.broadcastService.broadcast("msal:acquireTokenFailure", error);
            _this.getLogger().error("Error when acquiring token for scopes: " + request.scopes + " " + error);
            throw error;
        });
    };
    MsalService.prototype.acquireTokenPopup = function (request) {
        var _this = this;
        return _super.prototype.acquireTokenPopup.call(this, request)
            .then(function (authResponse) {
            _this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
            return authResponse;
        })
            .catch(function (error) {
            _this.broadcastService.broadcast("msal:acquireTokenFailure", error);
            _this.getLogger().error("Error when acquiring token for scopes : " + request.scopes + " " + error);
            throw error;
        });
    };
    MsalService.prototype.handleRedirectCallback = function (authOrTokenCallback, errorReceivedCallback) {
        var _this = this;
        _super.prototype.handleRedirectCallback.call(this, function (authError, authResponse) {
            if (authError) {
                if (!_this.getAccount()) {
                    _this.broadcastService.broadcast("msal:loginFailure", authError);
                }
                else {
                    _this.broadcastService.broadcast("msal:acquireTokenFailure", authError);
                }
                if (errorReceivedCallback) {
                    errorReceivedCallback(authError, authResponse.accountState);
                }
                else {
                    authOrTokenCallback(authError, authResponse);
                }
            }
            else if (authResponse) {
                if (authResponse.tokenType === "id_token") {
                    _this.broadcastService.broadcast("msal:loginSuccess", authResponse);
                }
                else {
                    _this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
                }
                if (errorReceivedCallback) {
                    authOrTokenCallback(authResponse);
                }
                else {
                    authOrTokenCallback(null, authResponse);
                }
            }
        });
    };
    MsalService.prototype.clearCacheForScope = function (accessToken) {
        return _super.prototype.clearCacheForScope.call(this, accessToken);
    };
    MsalService.prototype.getScopesForEndpoint = function (endpoint) {
        if (this.msalConfig.framework && this.msalConfig.framework.unprotectedResources) {
            this.getLogger().info("msalConfig.framework.unprotectedResources is deprecated, use msalAngularConfig.unprotectedResources");
        }
        // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.
        var isUnprotected = this.isUnprotectedResource(endpoint);
        if (isUnprotected) {
            return null;
        }
        var frameworkProtectedResourceMap = this.msalConfig.framework && this.msalConfig.framework.protectedResourceMap;
        if (frameworkProtectedResourceMap) {
            this.getLogger().info("msalConfig.framework.protectedResourceMap is deprecated, use msalAngularConfig.protectedResourceMap");
        }
        var protectedResourceMap = frameworkProtectedResourceMap && frameworkProtectedResourceMap.size ? frameworkProtectedResourceMap : new Map(this.msalAngularConfig.protectedResourceMap);
        // process all protected resources and send the matched one
        var keyForEndpoint = Array.from(protectedResourceMap.keys()).find(function (key) { return endpoint.indexOf(key) > -1; });
        if (keyForEndpoint) {
            return protectedResourceMap.get(keyForEndpoint);
        }
        /*
         * default resource will be clientid if nothing specified
         * App will use idtoken for calls to itself
         * check if it's staring from http or https, needs to match with app host
         */
        if (endpoint.indexOf("http://") > -1 || endpoint.indexOf("https://") > -1) {
            if (UrlUtils.getHostFromUri(endpoint) === UrlUtils.getHostFromUri(_super.prototype.getRedirectUri.call(this))) {
                return new Array(this.msalConfig.auth.clientId);
            }
        }
        else {
            /*
             * in angular level, the url for $http interceptor call could be relative url,
             * if it's relative call, we'll treat it as app backend call.
             */
            return new Array(this.msalConfig.auth.clientId);
        }
        // if not the app's own backend or not a domain listed in the endpoints structure
        return null;
    };
    MsalService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
        { type: Router },
        { type: BroadcastService }
    ]; };
    MsalService = __decorate([
        Injectable(),
        __param(0, Inject(MSAL_CONFIG)),
        __param(1, Inject(MSAL_CONFIG_ANGULAR))
    ], MsalService);
    return MsalService;
}(UserAgentApplication));

var MsalGuard = /** @class */ (function () {
    function MsalGuard(msalConfig, msalAngularConfig, authService, router, activatedRoute, location, platformLocation, broadcastService) {
        this.msalConfig = msalConfig;
        this.msalAngularConfig = msalAngularConfig;
        this.authService = authService;
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.location = location;
        this.platformLocation = platformLocation;
        this.broadcastService = broadcastService;
    }
    /**
     * Builds the absolute url for the destination page
     * @param path Relative path of requested page
     * @returns Full destination url
     */
    MsalGuard.prototype.getDestinationUrl = function (path) {
        // Absolute base url for the application (default to origin if base element not present)
        var baseElements = document.getElementsByTagName("base");
        var baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
        // Path of page (including hash, if using hash routing)
        var pathUrl = this.location.prepareExternalUrl(path);
        // Hash location strategy
        if (pathUrl.startsWith("#")) {
            return baseUrl + "/" + pathUrl;
        }
        // If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
        // Since baseUrl also includes /base, can just concatentate baseUrl + path
        return "" + baseUrl + path;
    };
    /**
     * Interactively prompt the user to login
     * @param url Path of the requested page
     */
    MsalGuard.prototype.loginInteractively = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var redirectStartPage;
            return __generator(this, function (_a) {
                if (this.msalAngularConfig.popUp) {
                    return [2 /*return*/, this.authService.loginPopup({
                            scopes: this.msalAngularConfig.consentScopes,
                            extraQueryParameters: this.msalAngularConfig.extraQueryParameters
                        })
                            .then(function () { return true; })
                            .catch(function () { return false; })];
                }
                redirectStartPage = this.getDestinationUrl(url);
                this.authService.loginRedirect({
                    redirectStartPage: redirectStartPage,
                    scopes: this.msalAngularConfig.consentScopes,
                    extraQueryParameters: this.msalAngularConfig.extraQueryParameters
                });
                return [2 /*return*/];
            });
        });
    };
    MsalGuard.prototype.canActivate = function (route, state) {
        var _this = this;
        this.authService.getLogger().verbose("location change event from old url to new url");
        // If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
        // short-circuit to prevent redirecting or popups.
        if (UrlUtils.urlContainsHash(window.location.hash) && WindowUtils.isInIframe()) {
            this.authService.getLogger().warning("redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
            return false;
        }
        if (!this.authService.getAccount()) {
            return this.loginInteractively(state.url);
        }
        return this.authService.acquireTokenSilent({
            scopes: [this.msalConfig.auth.clientId]
        })
            .then(function () { return true; })
            .catch(function (error) {
            if (InteractionRequiredAuthError.isInteractionRequiredError(error.errorCode)) {
                _this.authService.getLogger().info("Interaction required error in MSAL Guard, prompting for interaction.");
                return _this.loginInteractively(state.url);
            }
            _this.authService.getLogger().error("Non-interaction error in MSAL Guard: " + error.errorMessage);
            throw error;
        });
    };
    MsalGuard.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
        { type: MsalService },
        { type: Router },
        { type: ActivatedRoute },
        { type: Location },
        { type: PlatformLocation },
        { type: BroadcastService }
    ]; };
    MsalGuard = __decorate([
        Injectable(),
        __param(0, Inject(MSAL_CONFIG)),
        __param(1, Inject(MSAL_CONFIG_ANGULAR))
    ], MsalGuard);
    return MsalGuard;
}());

var MsalInterceptor = /** @class */ (function () {
    function MsalInterceptor(auth, broadcastService) {
        this.auth = auth;
        this.broadcastService = broadcastService;
    }
    MsalInterceptor.prototype.intercept = function (req, next) {
        var _this = this;
        var scopes = this.auth.getScopesForEndpoint(req.url);
        this.auth.getLogger().verbose("Url: " + req.url + " maps to scopes: " + scopes);
        // If there are no scopes set for this request, do nothing.
        if (!scopes) {
            return next.handle(req);
        }
        var token;
        // Acquire a token for this request, and attach as proper auth header.
        return from(this.auth.acquireTokenSilent({ scopes: scopes })
            .then(function (response) {
            token = response.tokenType === ServerHashParamKeys.ID_TOKEN ? response.idToken.rawIdToken : response.accessToken;
            var authHeader = "Bearer " + token;
            return req.clone({
                setHeaders: {
                    Authorization: authHeader,
                }
            });
        }))
            .pipe(mergeMap(function (nextReq) { return next.handle(nextReq); }), tap(function (event) { }, // tslint:disable-line
        function (// tslint:disable-line
        err) {
            if (err instanceof HttpErrorResponse && err.status === 401) {
                _this.auth.clearCacheForScope(token);
                _this.broadcastService.broadcast("msal:notAuthorized", err.message);
            }
        }));
    };
    MsalInterceptor.ctorParameters = function () { return [
        { type: MsalService },
        { type: BroadcastService }
    ]; };
    MsalInterceptor = __decorate([
        Injectable()
    ], MsalInterceptor);
    return MsalInterceptor;
}());

var defaultMsalAngularConfiguration = {
    consentScopes: [],
    popUp: false,
    extraQueryParameters: {},
    unprotectedResources: [],
    protectedResourceMap: []
};

var MsalModule = /** @class */ (function () {
    function MsalModule() {
    }
    MsalModule_1 = MsalModule;
    MsalModule.forRoot = function (config, angularConfig) {
        if (angularConfig === void 0) { angularConfig = defaultMsalAngularConfiguration; }
        return {
            ngModule: MsalModule_1,
            providers: [
                {
                    provide: MSAL_CONFIG,
                    useValue: config
                },
                {
                    provide: MSAL_CONFIG_ANGULAR,
                    useValue: angularConfig
                },
                MsalService
            ]
        };
    };
    var MsalModule_1;
    MsalModule = MsalModule_1 = __decorate([
        NgModule({
            imports: [CommonModule],
            declarations: [],
            providers: [MsalGuard, BroadcastService],
        })
    ], MsalModule);
    return MsalModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { BroadcastService, MSAL_CONFIG, MSAL_CONFIG_ANGULAR, MsalGuard, MsalInterceptor, MsalModule, MsalService, defaultMsalAngularConfiguration as ɵa };
//# sourceMappingURL=azure-msal-angular.js.map
