import { __decorate, __param, __awaiter } from 'tslib';
import { Injectable, InjectionToken, Inject, NgModule } from '@angular/core';
import { BehaviorSubject, from } from 'rxjs';
import { filter, map, mergeMap, tap } from 'rxjs/operators';
import { UserAgentApplication, UrlUtils, WindowUtils, InteractionRequiredAuthError, ServerHashParamKeys } from 'msal';
import { Router, ActivatedRoute } from '@angular/router';
import { Location, PlatformLocation, CommonModule } from '@angular/common';
import { HttpErrorResponse } from '@angular/common/http';

let BroadcastService = class BroadcastService {
    constructor() {
        this._msalSubject = new BehaviorSubject(1);
        this.msalItem$ = this._msalSubject.asObservable();
    }
    broadcast(type, payload) {
        this._msalSubject.next({ type, payload });
    }
    getMSALSubject() {
        return this._msalSubject;
    }
    getMSALItem() {
        return this.msalItem$;
    }
    subscribe(type, callback) {
        return this.msalItem$
            .pipe(filter(message => message.type === type), map(message => message.payload))
            .subscribe(callback);
    }
};
BroadcastService = __decorate([
    Injectable()
], BroadcastService);

class MSALError {
    constructor(error, errorDesc, scopes) {
        this._error = "";
        this._errorDesc = "";
        this._scopes = "";
        this._error = error;
        if (errorDesc) {
            this._errorDesc = errorDesc;
        }
        if (scopes) {
            this._scopes = scopes;
        }
    }
    get error() {
        return this._error;
    }
    set error(value) {
        this._error = value;
    }
    get errorDesc() {
        return this._errorDesc;
    }
    set errorDesc(value) {
        this._errorDesc = value;
    }
    get scopes() {
        return this._scopes;
    }
    set scopes(value) {
        this._scopes = value;
    }
}

const MSAL_CONFIG = new InjectionToken("MSAL_CONFIG");
const MSAL_CONFIG_ANGULAR = new InjectionToken("MSAL_CONFIG_ANGULAR");

const buildMsalConfig = (config) => {
    return Object.assign(Object.assign({}, config), { framework: Object.assign(Object.assign({}, config.framework), { isAngular: true }) });
};
const ɵ0 = buildMsalConfig;
let MsalService = class MsalService extends UserAgentApplication {
    constructor(msalConfig, msalAngularConfig, router, broadcastService) {
        super(buildMsalConfig(msalConfig));
        this.msalConfig = msalConfig;
        this.msalAngularConfig = msalAngularConfig;
        this.router = router;
        this.broadcastService = broadcastService;
        window.addEventListener("msal:popUpHashChanged", (e) => {
            this.getLogger().verbose("popUpHashChanged ");
        });
        window.addEventListener("msal:popUpClosed", (e) => {
            var errorParts = e.detail.split("|");
            var msalError = new MSALError(errorParts[0], errorParts[1]);
            if (this.getLoginInProgress()) {
                broadcastService.broadcast("msal:loginFailure", msalError);
                this.setloginInProgress(false);
            }
            else if (this.getAcquireTokenInProgress()) {
                broadcastService.broadcast("msal:acquireTokenFailure", msalError);
                this.setAcquireTokenInProgress(false);
            }
        });
        this.router.events.subscribe(event => {
            for (var i = 0; i < router.config.length; i++) {
                if (!router.config[i].canActivate) {
                    if (this.msalAngularConfig.unprotectedResources) {
                        if (!this.isEmpty(router.config[i].path) && !this.isUnprotectedResource(router.config[i].path)) {
                            this.msalAngularConfig.unprotectedResources.push(router.config[i].path);
                        }
                    }
                }
            }
        });
    }
    isUnprotectedResource(url) {
        const frameworkUnprotectedResources = this.msalConfig.framework && this.msalConfig.framework.unprotectedResources;
        const configUnprotectedResources = this.msalAngularConfig.unprotectedResources || [];
        const unprotectedResources = frameworkUnprotectedResources && frameworkUnprotectedResources.length ? frameworkUnprotectedResources : configUnprotectedResources;
        return unprotectedResources.some(resource => url.indexOf(resource) > -1);
    }
    isEmpty(str) {
        return (typeof str === "undefined" || !str || 0 === str.length);
    }
    loginPopup(request) {
        return super.loginPopup(request)
            .then((authResponse) => {
            this.broadcastService.broadcast("msal:loginSuccess", authResponse);
            return authResponse;
        })
            .catch((error) => {
            this.broadcastService.broadcast("msal:loginFailure", error);
            this.getLogger().error("Error during login:\n" + error.errorMessage);
            throw error;
        });
    }
    ssoSilent(request) {
        return super.ssoSilent(request)
            .then((authResponse) => {
            this.broadcastService.broadcast("msal:ssoSuccess", authResponse);
            return authResponse;
        })
            .catch((error) => {
            this.broadcastService.broadcast("msal:ssoFailure", error);
            this.getLogger().error("Error during login:\n" + error.errorMessage);
            throw error;
        });
    }
    acquireTokenSilent(request) {
        return super.acquireTokenSilent(request)
            .then((authResponse) => {
            this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
            return authResponse;
        })
            .catch((error) => {
            this.broadcastService.broadcast("msal:acquireTokenFailure", error);
            this.getLogger().error("Error when acquiring token for scopes: " + request.scopes + " " + error);
            throw error;
        });
    }
    acquireTokenPopup(request) {
        return super.acquireTokenPopup(request)
            .then((authResponse) => {
            this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
            return authResponse;
        })
            .catch((error) => {
            this.broadcastService.broadcast("msal:acquireTokenFailure", error);
            this.getLogger().error("Error when acquiring token for scopes : " + request.scopes + " " + error);
            throw error;
        });
    }
    handleRedirectCallback(authOrTokenCallback, errorReceivedCallback) {
        super.handleRedirectCallback((authError, authResponse) => {
            if (authError) {
                if (!this.getAccount()) {
                    this.broadcastService.broadcast("msal:loginFailure", authError);
                }
                else {
                    this.broadcastService.broadcast("msal:acquireTokenFailure", authError);
                }
                if (errorReceivedCallback) {
                    errorReceivedCallback(authError, authResponse.accountState);
                }
                else {
                    authOrTokenCallback(authError, authResponse);
                }
            }
            else if (authResponse) {
                if (authResponse.tokenType === "id_token") {
                    this.broadcastService.broadcast("msal:loginSuccess", authResponse);
                }
                else {
                    this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
                }
                if (errorReceivedCallback) {
                    authOrTokenCallback(authResponse);
                }
                else {
                    authOrTokenCallback(null, authResponse);
                }
            }
        });
    }
    clearCacheForScope(accessToken) {
        return super.clearCacheForScope(accessToken);
    }
    getScopesForEndpoint(endpoint) {
        if (this.msalConfig.framework && this.msalConfig.framework.unprotectedResources) {
            this.getLogger().info("msalConfig.framework.unprotectedResources is deprecated, use msalAngularConfig.unprotectedResources");
        }
        // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.
        const isUnprotected = this.isUnprotectedResource(endpoint);
        if (isUnprotected) {
            return null;
        }
        const frameworkProtectedResourceMap = this.msalConfig.framework && this.msalConfig.framework.protectedResourceMap;
        if (frameworkProtectedResourceMap) {
            this.getLogger().info("msalConfig.framework.protectedResourceMap is deprecated, use msalAngularConfig.protectedResourceMap");
        }
        const protectedResourceMap = frameworkProtectedResourceMap && frameworkProtectedResourceMap.size ? frameworkProtectedResourceMap : new Map(this.msalAngularConfig.protectedResourceMap);
        // process all protected resources and send the matched one
        const keyForEndpoint = Array.from(protectedResourceMap.keys()).find(key => endpoint.indexOf(key) > -1);
        if (keyForEndpoint) {
            return protectedResourceMap.get(keyForEndpoint);
        }
        /*
         * default resource will be clientid if nothing specified
         * App will use idtoken for calls to itself
         * check if it's staring from http or https, needs to match with app host
         */
        if (endpoint.indexOf("http://") > -1 || endpoint.indexOf("https://") > -1) {
            if (UrlUtils.getHostFromUri(endpoint) === UrlUtils.getHostFromUri(super.getRedirectUri())) {
                return new Array(this.msalConfig.auth.clientId);
            }
        }
        else {
            /*
             * in angular level, the url for $http interceptor call could be relative url,
             * if it's relative call, we'll treat it as app backend call.
             */
            return new Array(this.msalConfig.auth.clientId);
        }
        // if not the app's own backend or not a domain listed in the endpoints structure
        return null;
    }
};
MsalService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
    { type: Router },
    { type: BroadcastService }
];
MsalService = __decorate([
    Injectable(),
    __param(0, Inject(MSAL_CONFIG)),
    __param(1, Inject(MSAL_CONFIG_ANGULAR))
], MsalService);

let MsalGuard = class MsalGuard {
    constructor(msalConfig, msalAngularConfig, authService, router, activatedRoute, location, platformLocation, broadcastService) {
        this.msalConfig = msalConfig;
        this.msalAngularConfig = msalAngularConfig;
        this.authService = authService;
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.location = location;
        this.platformLocation = platformLocation;
        this.broadcastService = broadcastService;
    }
    /**
     * Builds the absolute url for the destination page
     * @param path Relative path of requested page
     * @returns Full destination url
     */
    getDestinationUrl(path) {
        // Absolute base url for the application (default to origin if base element not present)
        const baseElements = document.getElementsByTagName("base");
        const baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
        // Path of page (including hash, if using hash routing)
        const pathUrl = this.location.prepareExternalUrl(path);
        // Hash location strategy
        if (pathUrl.startsWith("#")) {
            return `${baseUrl}/${pathUrl}`;
        }
        // If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
        // Since baseUrl also includes /base, can just concatentate baseUrl + path
        return `${baseUrl}${path}`;
    }
    /**
     * Interactively prompt the user to login
     * @param url Path of the requested page
     */
    loginInteractively(url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.msalAngularConfig.popUp) {
                return this.authService.loginPopup({
                    scopes: this.msalAngularConfig.consentScopes,
                    extraQueryParameters: this.msalAngularConfig.extraQueryParameters
                })
                    .then(() => true)
                    .catch(() => false);
            }
            const redirectStartPage = this.getDestinationUrl(url);
            this.authService.loginRedirect({
                redirectStartPage,
                scopes: this.msalAngularConfig.consentScopes,
                extraQueryParameters: this.msalAngularConfig.extraQueryParameters
            });
        });
    }
    canActivate(route, state) {
        this.authService.getLogger().verbose("location change event from old url to new url");
        // If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
        // short-circuit to prevent redirecting or popups.
        if (UrlUtils.urlContainsHash(window.location.hash) && WindowUtils.isInIframe()) {
            this.authService.getLogger().warning("redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
            return false;
        }
        if (!this.authService.getAccount()) {
            return this.loginInteractively(state.url);
        }
        return this.authService.acquireTokenSilent({
            scopes: [this.msalConfig.auth.clientId]
        })
            .then(() => true)
            .catch((error) => {
            if (InteractionRequiredAuthError.isInteractionRequiredError(error.errorCode)) {
                this.authService.getLogger().info(`Interaction required error in MSAL Guard, prompting for interaction.`);
                return this.loginInteractively(state.url);
            }
            this.authService.getLogger().error(`Non-interaction error in MSAL Guard: ${error.errorMessage}`);
            throw error;
        });
    }
};
MsalGuard.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
    { type: MsalService },
    { type: Router },
    { type: ActivatedRoute },
    { type: Location },
    { type: PlatformLocation },
    { type: BroadcastService }
];
MsalGuard = __decorate([
    Injectable(),
    __param(0, Inject(MSAL_CONFIG)),
    __param(1, Inject(MSAL_CONFIG_ANGULAR))
], MsalGuard);

let MsalInterceptor = class MsalInterceptor {
    constructor(auth, broadcastService) {
        this.auth = auth;
        this.broadcastService = broadcastService;
    }
    intercept(req, next) {
        const scopes = this.auth.getScopesForEndpoint(req.url);
        this.auth.getLogger().verbose("Url: " + req.url + " maps to scopes: " + scopes);
        // If there are no scopes set for this request, do nothing.
        if (!scopes) {
            return next.handle(req);
        }
        let token;
        // Acquire a token for this request, and attach as proper auth header.
        return from(this.auth.acquireTokenSilent({ scopes })
            .then((response) => {
            token = response.tokenType === ServerHashParamKeys.ID_TOKEN ? response.idToken.rawIdToken : response.accessToken;
            const authHeader = `Bearer ${token}`;
            return req.clone({
                setHeaders: {
                    Authorization: authHeader,
                }
            });
        }))
            .pipe(mergeMap(nextReq => next.handle(nextReq)), tap(event => { }, // tslint:disable-line
        // tslint:disable-line
        err => {
            if (err instanceof HttpErrorResponse && err.status === 401) {
                this.auth.clearCacheForScope(token);
                this.broadcastService.broadcast("msal:notAuthorized", err.message);
            }
        }));
    }
};
MsalInterceptor.ctorParameters = () => [
    { type: MsalService },
    { type: BroadcastService }
];
MsalInterceptor = __decorate([
    Injectable()
], MsalInterceptor);

const defaultMsalAngularConfiguration = {
    consentScopes: [],
    popUp: false,
    extraQueryParameters: {},
    unprotectedResources: [],
    protectedResourceMap: []
};

var MsalModule_1;
let MsalModule = MsalModule_1 = class MsalModule {
    static forRoot(config, angularConfig = defaultMsalAngularConfiguration) {
        return {
            ngModule: MsalModule_1,
            providers: [
                {
                    provide: MSAL_CONFIG,
                    useValue: config
                },
                {
                    provide: MSAL_CONFIG_ANGULAR,
                    useValue: angularConfig
                },
                MsalService
            ]
        };
    }
};
MsalModule = MsalModule_1 = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [],
        providers: [MsalGuard, BroadcastService],
    })
], MsalModule);

/**
 * Generated bundle index. Do not edit.
 */

export { BroadcastService, MSAL_CONFIG, MSAL_CONFIG_ANGULAR, MsalGuard, MsalInterceptor, MsalModule, MsalService, defaultMsalAngularConfiguration as ɵa };
//# sourceMappingURL=azure-msal-angular.js.map
