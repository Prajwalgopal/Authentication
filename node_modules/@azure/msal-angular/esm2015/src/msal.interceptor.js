import { __decorate } from "tslib";
import { Injectable } from "@angular/core";
import { HttpErrorResponse } from "@angular/common/http";
import { from } from "rxjs";
import { mergeMap, tap } from "rxjs/operators";
import { MsalService } from "./msal.service";
import { BroadcastService } from "./broadcast.service";
import { ServerHashParamKeys } from "msal";
let MsalInterceptor = class MsalInterceptor {
    constructor(auth, broadcastService) {
        this.auth = auth;
        this.broadcastService = broadcastService;
    }
    intercept(req, next) {
        const scopes = this.auth.getScopesForEndpoint(req.url);
        this.auth.getLogger().verbose("Url: " + req.url + " maps to scopes: " + scopes);
        // If there are no scopes set for this request, do nothing.
        if (!scopes) {
            return next.handle(req);
        }
        let token;
        // Acquire a token for this request, and attach as proper auth header.
        return from(this.auth.acquireTokenSilent({ scopes })
            .then((response) => {
            token = response.tokenType === ServerHashParamKeys.ID_TOKEN ? response.idToken.rawIdToken : response.accessToken;
            const authHeader = `Bearer ${token}`;
            return req.clone({
                setHeaders: {
                    Authorization: authHeader,
                }
            });
        }))
            .pipe(mergeMap(nextReq => next.handle(nextReq)), tap(event => { }, // tslint:disable-line
        // tslint:disable-line
        err => {
            if (err instanceof HttpErrorResponse && err.status === 401) {
                this.auth.clearCacheForScope(token);
                this.broadcastService.broadcast("msal:notAuthorized", err.message);
            }
        }));
    }
};
MsalInterceptor.ctorParameters = () => [
    { type: MsalService },
    { type: BroadcastService }
];
MsalInterceptor = __decorate([
    Injectable()
], MsalInterceptor);
export { MsalInterceptor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXNhbC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhenVyZS9tc2FsLWFuZ3VsYXIvIiwic291cmNlcyI6WyJzcmMvbXNhbC5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBS0gsaUJBQWlCLEVBQ3BCLE1BQU0sc0JBQXNCLENBQUM7QUFFOUIsT0FBTyxFQUFjLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRS9DLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQWdCLG1CQUFtQixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBR3pELElBQWEsZUFBZSxHQUE1QixNQUFhLGVBQWU7SUFDeEIsWUFBb0IsSUFBaUIsRUFBWSxnQkFBa0M7UUFBL0QsU0FBSSxHQUFKLElBQUksQ0FBYTtRQUFZLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7SUFBRyxDQUFDO0lBRXZGLFNBQVMsQ0FBQyxHQUFxQixFQUFFLElBQWlCO1FBQzlDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxDQUFDO1FBRWhGLDJEQUEyRDtRQUMzRCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO1FBRUQsSUFBSSxLQUFhLENBQUM7UUFFbEIsc0VBQXNFO1FBQ3RFLE9BQU8sSUFBSSxDQUNQLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUNuQyxJQUFJLENBQUMsQ0FBQyxRQUFzQixFQUFFLEVBQUU7WUFDN0IsS0FBSyxHQUFHLFFBQVEsQ0FBQyxTQUFTLEtBQUssbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztZQUNqSCxNQUFNLFVBQVUsR0FBRyxVQUFVLEtBQUssRUFBRSxDQUFDO1lBQ3JDLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQztnQkFDYixVQUFVLEVBQUU7b0JBQ1IsYUFBYSxFQUFFLFVBQVU7aUJBQzVCO2FBQ0osQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQ1Q7YUFDQSxJQUFJLENBQ0QsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUN6QyxHQUFHLENBQ0MsS0FBSyxDQUFDLEVBQUUsR0FBRSxDQUFDLEVBQUUsc0JBQXNCO1FBQ25DLEFBRGEsc0JBQXNCO1FBQ25DLEdBQUcsQ0FBQyxFQUFFO1lBQ0YsSUFBSSxHQUFHLFlBQVksaUJBQWlCLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7Z0JBQ3hELElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3BDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ3RFO1FBQ0wsQ0FBQyxDQUNKLENBQ0osQ0FBQztJQUNOLENBQUM7Q0FDSixDQUFBOztZQXZDNkIsV0FBVztZQUE4QixnQkFBZ0I7O0FBRDFFLGVBQWU7SUFEM0IsVUFBVSxFQUFFO0dBQ0EsZUFBZSxDQXdDM0I7U0F4Q1ksZUFBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgSHR0cFJlcXVlc3QsXHJcbiAgICBIdHRwSGFuZGxlcixcclxuICAgIEh0dHBFdmVudCxcclxuICAgIEh0dHBJbnRlcmNlcHRvcixcclxuICAgIEh0dHBFcnJvclJlc3BvbnNlXHJcbn0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vbi9odHRwXCI7XHJcblxyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tIH0gZnJvbSBcInJ4anNcIjtcclxuaW1wb3J0IHsgbWVyZ2VNYXAsIHRhcCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xyXG5cclxuaW1wb3J0IHtNc2FsU2VydmljZX0gZnJvbSBcIi4vbXNhbC5zZXJ2aWNlXCI7XHJcbmltcG9ydCB7IEJyb2FkY2FzdFNlcnZpY2UgfSBmcm9tIFwiLi9icm9hZGNhc3Quc2VydmljZVwiO1xyXG5pbXBvcnQgeyBBdXRoUmVzcG9uc2UsIFNlcnZlckhhc2hQYXJhbUtleXMgfSBmcm9tIFwibXNhbFwiO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTXNhbEludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYXV0aDogTXNhbFNlcnZpY2UgLCAgcHJpdmF0ZSBicm9hZGNhc3RTZXJ2aWNlOiBCcm9hZGNhc3RTZXJ2aWNlKSB7fVxyXG5cclxuICAgIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xyXG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuYXV0aC5nZXRTY29wZXNGb3JFbmRwb2ludChyZXEudXJsKTtcclxuICAgICAgICB0aGlzLmF1dGguZ2V0TG9nZ2VyKCkudmVyYm9zZShcIlVybDogXCIgKyByZXEudXJsICsgXCIgbWFwcyB0byBzY29wZXM6IFwiICsgc2NvcGVzKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHNjb3BlcyBzZXQgZm9yIHRoaXMgcmVxdWVzdCwgZG8gbm90aGluZy5cclxuICAgICAgICBpZiAoIXNjb3Blcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB0b2tlbjogc3RyaW5nO1xyXG5cclxuICAgICAgICAvLyBBY3F1aXJlIGEgdG9rZW4gZm9yIHRoaXMgcmVxdWVzdCwgYW5kIGF0dGFjaCBhcyBwcm9wZXIgYXV0aCBoZWFkZXIuXHJcbiAgICAgICAgcmV0dXJuIGZyb20oXHJcbiAgICAgICAgICAgIHRoaXMuYXV0aC5hY3F1aXJlVG9rZW5TaWxlbnQoeyBzY29wZXMgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZTogQXV0aFJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSByZXNwb25zZS50b2tlblR5cGUgPT09IFNlcnZlckhhc2hQYXJhbUtleXMuSURfVE9LRU4gPyByZXNwb25zZS5pZFRva2VuLnJhd0lkVG9rZW4gOiByZXNwb25zZS5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRoSGVhZGVyID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGF1dGhIZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICBtZXJnZU1hcChuZXh0UmVxID0+IG5leHQuaGFuZGxlKG5leHRSZXEpKSxcclxuICAgICAgICAgICAgdGFwKFxyXG4gICAgICAgICAgICAgICAgZXZlbnQgPT4ge30sIC8vIHRzbGludDpkaXNhYmxlLWxpbmVcclxuICAgICAgICAgICAgICAgIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvclJlc3BvbnNlICYmIGVyci5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGguY2xlYXJDYWNoZUZvclNjb3BlKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RTZXJ2aWNlLmJyb2FkY2FzdChcIm1zYWw6bm90QXV0aG9yaXplZFwiLCBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iXX0=